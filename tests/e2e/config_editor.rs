use crate::common::harness::EditorTestHarness;
use crossterm::event::{KeyCode, KeyModifiers};
use std::fs;

/// Test that the config editor command is registered by the plugin
#[test]
fn test_config_editor_command_registered() {
    // Create a temporary project directory
    let temp_dir = tempfile::TempDir::new().unwrap();
    let project_root = temp_dir.path().join("project_root");
    fs::create_dir(&project_root).unwrap();

    // Create plugins directory
    let plugins_dir = project_root.join("plugins");
    fs::create_dir(&plugins_dir).unwrap();

    // Copy the config_editor.ts plugin
    let plugin_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config_editor.ts");
    let plugin_dest = plugins_dir.join("config_editor.ts");
    fs::copy(&plugin_source, &plugin_dest).unwrap();

    // Copy the config-schema.json file (generated by build.rs)
    let schema_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config-schema.json");
    let schema_dest = plugins_dir.join("config-schema.json");
    fs::copy(&schema_source, &schema_dest).unwrap();

    // Create harness with the project directory
    let mut harness =
        EditorTestHarness::with_config_and_working_dir(120, 30, Default::default(), project_root)
            .unwrap();

    // Initial render
    harness.render().unwrap();

    // Open command palette
    harness
        .send_key(KeyCode::Char('p'), KeyModifiers::CONTROL)
        .unwrap();
    harness.render().unwrap();

    // Type to find the Edit Configuration command
    harness.type_text("Edit Configuration").unwrap();
    harness.render().unwrap();

    // The config editor command should be registered and visible in the palette
    harness.assert_screen_contains("Edit Configuration");
    harness.assert_screen_contains("config_editor");
}

/// Test that the config schema is properly generated
#[test]
fn test_config_schema_exists_and_valid() {
    let schema_path = std::env::current_dir()
        .unwrap()
        .join("plugins/config-schema.json");

    // Check file exists
    assert!(schema_path.exists(), "config-schema.json should exist");

    // Read and parse
    let content = fs::read_to_string(&schema_path).unwrap();
    let schema: serde_json::Value = serde_json::from_str(&content).unwrap();

    // Verify basic schema structure
    assert!(schema.get("$schema").is_some(), "Should have $schema");
    assert!(schema.get("$defs").is_some(), "Should have $defs");
    assert!(schema.get("$ref").is_some(), "Should have root $ref");

    // Verify Config definition exists
    let defs = schema.get("$defs").unwrap();
    assert!(
        defs.get("Config").is_some(),
        "Should have Config definition"
    );
    assert!(
        defs.get("EditorConfig").is_some(),
        "Should have EditorConfig definition"
    );
    assert!(
        defs.get("FileExplorerConfig").is_some(),
        "Should have FileExplorerConfig definition"
    );

    // Verify Config has expected properties
    let config = defs.get("Config").unwrap();
    let properties = config.get("properties").unwrap();
    assert!(properties.get("theme").is_some(), "Config should have theme");
    assert!(
        properties.get("editor").is_some(),
        "Config should have editor"
    );
    assert!(
        properties.get("file_explorer").is_some(),
        "Config should have file_explorer"
    );
}

/// Test that the HighlighterPreference enum is correctly generated
#[test]
fn test_config_schema_enums() {
    let schema_path = std::env::current_dir()
        .unwrap()
        .join("plugins/config-schema.json");

    let content = fs::read_to_string(&schema_path).unwrap();
    let schema: serde_json::Value = serde_json::from_str(&content).unwrap();

    let defs = schema.get("$defs").unwrap();

    // Check HighlighterPreference enum
    let highlighter_pref = defs.get("HighlighterPreference").unwrap();
    assert_eq!(
        highlighter_pref.get("type").unwrap().as_str().unwrap(),
        "string"
    );

    let enum_values = highlighter_pref.get("enum").unwrap().as_array().unwrap();
    assert!(enum_values.contains(&serde_json::json!("auto")));
    assert!(enum_values.contains(&serde_json::json!("tree-sitter")));
    assert!(enum_values.contains(&serde_json::json!("textmate")));
}

/// Test that config files saved by the editor can be deserialized
#[test]
fn test_config_file_deserialization() {
    use fresh::config::Config;

    // Create a sample config JSON that matches the schema
    let config_json = r#"{
        "theme": "high-contrast",
        "editor": {
            "tab_size": 4,
            "line_numbers": true,
            "relative_line_numbers": false,
            "line_wrap": false,
            "syntax_highlighting": true,
            "auto_indent": true
        },
        "file_explorer": {
            "show_hidden": false,
            "show_gitignored": false,
            "respect_gitignore": true,
            "width": 0.2
        },
        "active_keybinding_map": "default"
    }"#;

    // Verify it can be deserialized as a valid Config
    let result: Result<Config, _> = serde_json::from_str(config_json);
    assert!(
        result.is_ok(),
        "Config JSON should deserialize: {:?}",
        result.err()
    );

    let config = result.unwrap();
    assert_eq!(config.theme, "high-contrast");
    assert_eq!(config.editor.tab_size, 4);
    assert!(config.editor.line_numbers);
    assert!(!config.file_explorer.show_hidden);
}

/// Test that a minimal config file can be loaded
#[test]
fn test_minimal_config_deserialization() {
    use fresh::config::Config;

    // Minimal config - only required fields or fields without defaults
    let minimal_json = r#"{}"#;

    let result: Result<Config, _> = serde_json::from_str(minimal_json);
    assert!(
        result.is_ok(),
        "Empty config should deserialize with defaults: {:?}",
        result.err()
    );
}

/// Test that config with custom keybindings can be loaded
#[test]
fn test_config_with_keybindings() {
    use fresh::config::Config;

    let config_json = r#"{
        "keybindings": [
            {
                "key": "s",
                "modifiers": ["ctrl"],
                "action": "save"
            },
            {
                "keys": [
                    {"key": "x", "modifiers": ["ctrl"]},
                    {"key": "s", "modifiers": ["ctrl"]}
                ],
                "action": "save"
            }
        ]
    }"#;

    let result: Result<Config, _> = serde_json::from_str(config_json);
    assert!(
        result.is_ok(),
        "Config with keybindings should deserialize: {:?}",
        result.err()
    );

    let config = result.unwrap();
    assert_eq!(config.keybindings.len(), 2);
}

/// Test that cursor position is preserved after toggling a section
/// This test reproduces the bug where cursor jumps to top after expand/collapse
#[test]
fn test_config_editor_cursor_preserved_after_toggle() {
    // Create a temporary project directory
    let temp_dir = tempfile::TempDir::new().unwrap();
    let project_root = temp_dir.path().join("project_root");
    fs::create_dir(&project_root).unwrap();

    // Create plugins directory and copy files
    let plugins_dir = project_root.join("plugins");
    fs::create_dir(&plugins_dir).unwrap();

    let plugin_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config_editor.ts");
    fs::copy(&plugin_source, plugins_dir.join("config_editor.ts")).unwrap();

    let schema_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config-schema.json");
    fs::copy(&schema_source, plugins_dir.join("config-schema.json")).unwrap();

    // Create a config file with nested sections
    let config_content = r#"{"theme": "test-theme", "editor": {"tab_size": 4}}"#;
    fs::write(project_root.join("config.json"), config_content).unwrap();

    // Create harness
    let mut harness =
        EditorTestHarness::with_config_and_working_dir(120, 40, Default::default(), project_root)
            .unwrap();

    harness.render().unwrap();

    // Open command palette and run Edit Configuration
    harness
        .send_key(KeyCode::Char('p'), KeyModifiers::CONTROL)
        .unwrap();
    harness.render().unwrap();
    harness.type_text("Edit Configuration").unwrap();
    harness.render().unwrap();
    harness
        .send_key(KeyCode::Enter, KeyModifiers::NONE)
        .unwrap();

    // Process async operations to let the config editor load
    for _ in 0..30 {
        harness.process_async_and_render().unwrap();
    }

    // Move cursor down to find a section (e.g., "editor" section)
    // The editor should show sections like: theme, editor, file_explorer, etc.
    // Navigate down to find a section
    for _ in 0..5 {
        harness
            .send_key(KeyCode::Down, KeyModifiers::NONE)
            .unwrap();
        harness.render().unwrap();
    }

    // Record cursor line before toggle
    let screen_before = harness.screen_to_string();

    // Press Tab to toggle the section (expand/collapse)
    harness
        .send_key(KeyCode::Tab, KeyModifiers::NONE)
        .unwrap();

    // Process any async operations
    for _ in 0..5 {
        harness.process_async_and_render().unwrap();
    }

    let screen_after = harness.screen_to_string();

    // The cursor should NOT jump back to the top of the buffer
    // We verify this by checking that the content changed (section toggled)
    // but the view didn't reset to show only the header at top

    // If cursor jumped to top, the first visible content line would be the header
    // If cursor stayed, we should still see content from the middle of the buffer

    // This is a basic check - the toggle should work without errors
    // The main thing we're testing is that the plugin doesn't crash with TextEncoder error
    assert!(
        screen_after.contains("Configuration") || screen_after.contains("Config"),
        "Config editor should still be visible after toggle"
    );

    // Check that no error messages appeared (e.g., TextEncoder not defined)
    assert!(
        !screen_after.contains("TextEncoder"),
        "Should not see TextEncoder error on screen"
    );
}

/// Test that config editor opens and shows content (integration test)
#[test]
fn test_config_editor_opens_with_content() {
    // Create a temporary project directory
    let temp_dir = tempfile::TempDir::new().unwrap();
    let project_root = temp_dir.path().join("project_root");
    fs::create_dir(&project_root).unwrap();

    // Create plugins directory and copy files
    let plugins_dir = project_root.join("plugins");
    fs::create_dir(&plugins_dir).unwrap();

    let plugin_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config_editor.ts");
    fs::copy(&plugin_source, plugins_dir.join("config_editor.ts")).unwrap();

    let schema_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config-schema.json");
    fs::copy(&schema_source, plugins_dir.join("config-schema.json")).unwrap();

    // Create a config file in the project
    let config_content = r#"{"theme": "test-theme", "editor": {"tab_size": 8}}"#;
    fs::write(project_root.join("config.json"), config_content).unwrap();

    // Create harness
    let mut harness =
        EditorTestHarness::with_config_and_working_dir(120, 40, Default::default(), project_root)
            .unwrap();

    harness.render().unwrap();

    // Open command palette and run Edit Configuration
    harness
        .send_key(KeyCode::Char('p'), KeyModifiers::CONTROL)
        .unwrap();
    harness.render().unwrap();
    harness.type_text("Edit Configuration").unwrap();
    harness.render().unwrap();
    harness
        .send_key(KeyCode::Enter, KeyModifiers::NONE)
        .unwrap();

    // Process async operations multiple times
    for _ in 0..20 {
        harness.process_async_and_render().unwrap();
    }

    let screen = harness.screen_to_string();

    // The config editor should be loading - check status bar
    // Note: Due to async loading, the editor may still be loading
    // This test verifies the command was executed
    assert!(
        screen.contains("Config") || screen.contains("Loading"),
        "Should show config editor or loading state"
    );
}
